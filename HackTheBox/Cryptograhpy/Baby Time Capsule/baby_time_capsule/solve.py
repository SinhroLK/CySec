from Crypto.Util.number import long_to_bytes
from binascii import unhexlify
from functools import reduce
from gmpy2 import root
import gmpy2
gmpy2.get_context().precision = 4096
from itertools import combinations
from Crypto.Util.number import long_to_bytes

"Hastads Broadcast attack on e=5"


def chinese_remainder_theorem(items):
    # Determine N, the product of all n_i
    N = 1
    for a, n in items:
        N *= n

    # Find the solution (mod N)
    result = 0
    for a, n in items:
        m = N // n
        r, s, d = extended_gcd(n, m)
        if d != 1:
            raise "Input not pairwise co-prime"
        result += a * s * m

    # Make sure we return the canonical solution.
    return result % N


def extended_gcd(a, b):
    x, y = 0, 1
    lastx, lasty = 1, 0

    while b:
        a, (q, b) = b, divmod(a, b)
        x, lastx = lastx - q * x, x
        y, lasty = lasty - q * y, y

    return (lastx, lasty, a)


def mul_inv(a, b):
    b0 = b
    x0, x1 = 0, 1
    if b == 1:
        return 1
    while a > 1:
        q = a // b
        a, b = b, a % b
        x0, x1 = x1 - q * x0, x0
    if x1 < 0:
        x1 += b0
    return x1



n="AF76B1FAD95AA995D533F5A5B6EB997D1FDE958FAD38D13BD8BA45A05404C14DE08B8FC5B08C1BE14E2A26698510A3A2DD88C2B25BB123019C92F4DCF1EFCEA44E662104494EA70933D0F2B8FFCE41BC5F7E91DF9AF90A7C26BE56DA8DB8A8EB047F58DBE117FC7F89C050042F3F0B367E8CE2170B9557D24D32F02DBFC37A4B"
n=n.lower()
e=5
n1=int(n,16)
ct="121B499E724F67C3E380F536B1E5CA0FD974D28D5CFFD5ABB7BC29D94B9B3A19B801A6F1324B50DF095BB266C90A2ACD603E1DD57D14F06E4ECE8EA22CA021DF0DA40596870ABD37F6625BD9ED8774B7286E111343F3319782037A93BAF6F24E04ADB72A9400EF9C2D1AB6B07BAA90FEC76E5DCB798A8E6995CCBF8D2C5D7790"
ct=ct.lower()
ct1=int(ct,16)

a={"c": "1A4F4749F516DAE233F28722831D8774B05E544D8C8B2B70E592FE462DB0954810DE640CF5A91D2B37CCDD5863C7FC00EFB81CD2568EB5B9DD9F645B71698F1F1E696441EF6F9BD917D4BF011AFBEF384ABFEE5B3CEFDDDD7C63496850EA13965B2D873C8AC6E37F9D27CB81D0920163484E110B8B01B2FF7542181CB002A552", "pubkey": ["678B763B5BDCD45DBDED0FCA992813CD01D9D8875E99A34F26E8AFBE1014749F0E599BAFD6A1BD0315794C3CF7858B830124D4ECAC1ED141C706D52504C075A4F9E24E7AFBD27616EDFFBDED666011E837272FB35A5D101A0240229344611440D1DCA184B607B2256422B76F78973618B9C48313B1A35D6F885072D2315288CD", "5"]}

b={"c": "B67957C271A4924E7F21564D4E64CD23465A6BBCF3D6B24A6CB60181FA511D8AA2361B7DE7D65C4CA4CA2109D277CACB058BBE34A425ED1A7ACA5EF9D2FFF83C45C858C15781285641F03403BC229C7A2CA6AFCF03F5067E856CADF737D7E8F5CC319B9354A5F822BE83F4BEE65AAE95DD55123E172AB455D88D50716FB1839B", "pubkey": ["F331F4ACCF507CF93C2CEEB02F2C0B26570CC0FDFFEB09E014D46F1DD5F9595AB58F90D35B0EE907D35FFBE61B989B3A33D6DB97C6CB6BD516AE777C4A49F1B08734E17E561EABFB320C2F7B9CD88F1DF82E8B449D12F47C7856785796C4518908EDD996CE6FFC3101E3531109315D165B9F2EB143DA056E11A2751BD2AC74E1", "5"]}

c={"c": "2B1E2D2B4454A594A5C88131563B60B05538CD5AFF0470EC805ECE6AA1D6162077C601FDC62546DD79C730EC258890FC5DD7A241BCC9E417285524D437F2BD081B326FB10F2353E56C69F87E7ED88E0D832CBE121049DA7392FBBA47C189895C3EE3B23C763BC34997CC5BDE22236BFDB5836F2FC5FBFAF3A1FCF55AFA680B1E", "pubkey": ["A036FF5883A6A0D004675194AE0A270774CF32E45B9B45E8B1550F53D5F0C9C408B8C8C0FC42C57517EBEB17EBEC1A275504E373AEC2757857AA09B3B2216C2159DBE327DAB53C9ED65009494EE05594B7EABCCEF3D5BDDD99758521BB36B2F4EC52EE9C332ECAEBF5697BBB00F6659693AE737CE70FD951635960A098CDCD79", "5"]}

d={"c": "6531B678C859F217C6BF9D41D228E690161A911FF8ED03610E512EAF632EDBDF005C6F9B29283C7079447E53AF8FE797C7AEED96680017A8A3FECB641AAAEE476F85474494B6F2D92CA96BC7706D048E69095D53356DEE74CE62B0D5B9B15F754EC8BC17003685F41C0FCF77B2DF5ECEF482DA4D78C06C684DE8F34391CCD8A8", "pubkey": ["7803A6A426613A5BE6F946B18245EC4B01595E6FF26BB2E1650FFC87CDC2148AFDD3C25FBCCF931CD62616A20830EE9387D2AA74FC089676E3D8D194201C595D08C56D44EDCCADF970109772DAFD5E97477153D7F865E193DF745B7D40F4876CA5BB723979E166EFDE34EDE9AEF9CF1BF08B04F1B011020F3584EA318C43A7E7", "5"]}



n2=a["pubkey"][0].lower()
n2=int(n2,16)

ct2=a["c"]
ct2=ct2.lower()
ct2=int(ct2,16)

n3=b["pubkey"][0].lower()
n3=int(n3,16)

ct3=b["c"]
ct3=ct3.lower()
ct3=int(ct3,16)

n4=c["pubkey"][0].lower()
n4=int(n4,16)

ct4=c["c"]
ct4=ct4.lower()
ct4=int(ct4,16)

n5=d["pubkey"][0].lower()
n5=int(n5,16)

ct5=d["c"]
ct5=ct5.lower()
ct5=int(ct5,16)


c = [ct1, ct2, ct3, ct4,ct5]
n = [n1, n2, n3, n4, n5]
    
    
    
for i,j,k,l,m in combinations(range(5),5):
    C = chinese_remainder_theorem([(c[i], n[i]), (c[j], n[j]), (c[k], n[k]),(c[l], n[l]), (c[m], n[m])])
try:
    M = int(root(C, 5))
except ValueError:
    pass
else:
    print(long_to_bytes(M))